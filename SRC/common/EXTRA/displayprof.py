# -*- python -*-
# $RCSfile: displayprof.py,v $
# $Revision: 1.4 $
# $Author: vrc $
# $Date: 2007-09-26 22:02:18 $

"""
This software was produced by NIST, an agency of the U.S. government,
and by statute is not subject to copyright in the United States.
Recipients of this software assume all responsibilities associated
with its operation, modification and maintenance.

Written by Steve Langer, loosely based on pstats.py by James Roskind.

The displayprof module reads profiling statistics generated by
profiler.py.

This file can be used in two ways.  Importing it into python will give
you access to the Stats class, which has functions for reading profile
data and displaying it in various ways.  Alternatively, running this
python script directly ("python -i displayprof.py etc.") lets you type
the same function names interactively without knowing that they're
part of a class.

"""

import os, re, string, struct

timefactor = 1000                       # multiplies printed times

class Function:
    def __init__(self, name, idno):
        try:
            self.file, self.lineno, self.name = string.split(name, ':')
        except:
            print name
            raise
        self.lineno = string.atoi(self.lineno)
        self.idno = idno                # integer id for quick reference
        self.subroutines = {}
        self.suproutines = {}
        self.totaltime = 0
        self.owntime = 0

    def fullname(self):
        return "%s:%d(%s)" % (self.file, self.lineno, self.name)

    def stats(self):
        if self.ncalls > 0:
            scale = 1./self.ncalls
        else:
            scale = 1.0
        return (self.ncalls,
                timefactor*self.owntime,
                timefactor*self.owntime*scale,
                timefactor*self.totaltime,
                timefactor*self.totaltime*scale,
                self.fullname())

    def __repr__(self):
        return "%6d %10.4f %10.4f    %10.4f %10.4f   %s" % self.stats()


    def get_callees(self, funcdict):
        """
        Return a tuple (ncalls, %time, name) for each subroutine
        called by the function.  %time is the percentage of the
        function's total running time devoted to the subroutine.  Time
        spent in the function itself is listed as '<self>' so that the
        total percentages add up correctly.
        """
        time = reduce(lambda x,y:x+y,
                      [sub.time for sub in self.subroutines.values()],
                      self.owntime)
        if time != 0.0:
            return [(sub.ncalls, 100.*sub.time/time, funcdict[key].fullname())
                    for key, sub in self.subroutines.items()] \
                    + [(self.ncalls, 100.*self.owntime/time, '<self>')]
        return []

    def get_callers(self, funcdict):
        """
        Return a tuple (ncalls, %time, name) for each routine that
        calls the function. %time is the percentage of the function's
        total running time during which it was called by the named
        routine.
        """
        time = reduce(lambda x,y:x+y,
                      [sup.time for sup in self.suproutines.values()], 0.0)
        if time != 0.0:
            return [(sup.ncalls, 100.*sup.time/time, funcdict[key].fullname())
                    for key, sup in self.suproutines.items()]
        return []

class SubroutineData:
    def __init__(self, ncalls, time):
        self.ncalls = ncalls
        self.time = time

#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#

def readFunction(file):
    try:
        namelen = struct.unpack('<i', file.read(struct.calcsize('<i')))[0]
        fmt = '<%dsi' % namelen
        name, idno = struct.unpack(fmt, file.read(struct.calcsize(fmt)))
        func = Function(name, idno)
        fmt = '<iiiff'
        func.ncalls, nsubs, nsups, func.owntime, func.totaltime = \
                     struct.unpack(fmt, file.read(struct.calcsize(fmt)))

        fmt = '<iif'
        nbytes = struct.calcsize(fmt)
        for i in range(nsubs):
            idno, ncalls, time = struct.unpack(fmt, file.read(nbytes))
            func.subroutines[idno] = SubroutineData(ncalls, time)
        for i in range(nsups):
            idno, ncalls, time = struct.unpack(fmt, file.read(nbytes))
            func.suproutines[idno] = SubroutineData(ncalls, time)
        return func
    except struct.error:
        return None

#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#

class Stats:
    def __init__(self, filename):
        self.functions = {}             # assigns names to integer function ids
        self.allfuncs = []              # sorted list of all functions
        self.ncalls = 0
        self.totaltime = 0

        file = open(filename, 'rb')
        try:
            self.totaltime, self.ncalls = \
                            struct.unpack('<fi',
                                          file.read(struct.calcsize('<fi')))
        except struct.error:
            raise UserWarning("Invalid profile file?")
        func = readFunction(file)
        while not func is None:
            self.functions[func.idno] = func
            self.allfuncs.append(func)
            func = readFunction(file)

    def get_function(self, file, line, name):
        for func in self.allfuncs:      # slow, but I'm lazy
            if func.name == name and func.lineno == line and func.file == file:
                return func
        

    def strip_dirs(self):
        "Remove directory information from file names."
        for function in self.allfuncs:
            function.file = os.path.basename(function.file)
        return self

    def sort_stats(self, *criteria):
        """
        Sort statistics according to the given criteria.  More than
        one criterion may be given.  Criterion 2 is used if criterion
        1 can't make a decision, etc.
        """
        if criteria != (None,):
            try:
                self.allfuncs.sort(getSorter(criteria))
            except KeyError:
                print "Valid sorting criteria are:",
                for key in sorters.keys():
                    print key,
                print ''
        return self

    def reverse(self):
        "Reverse the current sorting order."
        self.allfuncs.reverse()
        return self

    def print_totals(self):
        print "   ", len(self.allfuncs), "functions"
        print "   ", self.ncalls, "function calls"
        print "    totaltime =", 1000*self.totaltime, "ms"

    def print_stats(self, *restrictions):
        """
        Print profiling statistics, limiting the output by the given
        restrictions.

        For each function, the output is
          ncalls:   the number of times the function was called
          self:     the amount of time spent in the function's own code
          percall:  self/ncalls
          total:    the amount of time spent in the function and its subroutines
          percall:  total/ncalls
          file:function(line)

          
        """
        # make a copy of the function list and apply restrictions to it
        funcs = self.allfuncs[:]
        for restriction in restrictions:
            funcs = restriction_ops[type(restriction)](funcs, restriction)
        if funcs:
            print "ncalls        self   percall         total    percall    file:line(function)"
            print "-"*80
            for function in funcs:
                print function


    def print_callees(self, rgxp=""):
        regexp = re.compile(rgxp)
        for function in self.allfuncs:
            if regexp.search(function.fullname()):
                subs = function.get_callees(self.functions)
                if subs:
                    subs.sort(subsort)
                    print ''
                    print 'caller =', function.fullname()
                    print ' ncalls  %time  subroutine'
                    print '-'*40
                    for sub in subs:
                        print "%6d  %6.2f  %s" % sub
        
    def print_callers(self, rgxp=""):
        regexp = re.compile(rgxp)
        for function in self.allfuncs:
            if regexp.search(function.fullname()):
                sups = function.get_callers(self.functions)
                if sups:
                    sups.sort(subsort)
                    print ''
                    print 'callee =', function.fullname()
                    print ' ncalls  %time  subroutine'
                    print '-'*40
                    for sup in sups:
                        print "%6d  %6.2f  %s" % sup

    def butterfly(self, rgxp=""):
        regexp = re.compile(rgxp)
        for function in self.allfuncs:
            if regexp.search(function.fullname()):
                sups = function.get_callers(self.functions)
                sups.sort(subsort)
                sups.reverse()
                subs = function.get_callees(self.functions)
                subs.sort(subsort)
                print ' ncalls  %time  subroutine'
                print '-'*40
                for sup in sups:
                    print "%6d  %6.2f  %s" % sup
                print ''
                print '^---callers/ %s /callees---v' % function.fullname()
                print ''
                for sub in subs:
                    print "%6d  %6.2f  %s" % sub

# Sort the tuples returned by Function.get_callers and
# Function.get_callees in order of reverse percent time.

def subsort(a, b):
    if a[1] < b[1]: return 1
    if a[1] > b[1]: return -1
    return 0

#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#

# Functions for sorting results

def cmp_tot(x,y):
    if x.totaltime < y.totaltime: return 1
    if x.totaltime > y.totaltime: return -1
    return 0

def cmp_own(x,y):
    if x.owntime < y.owntime: return 1
    if x.owntime > y.owntime: return -1
    return 0

def cmp_ncalls(x,y):
    if x.ncalls < y.ncalls: return 1
    if x.ncalls > y.ncalls: return -1
    return 0

def cmp_percall(x,y):
    if x.ncalls == 0 and y.ncalls == 0: return 0
    if x.ncalls == 0: return 1
    if y.ncalls == 0: return -1
    xt = x.totaltime/x.ncalls
    yt = y.totaltime/y.ncalls
    if xt < yt: return 1
    if xt > yt: return -1
    return 0

def cmp_selfpercall(x,y):
    if x.ncalls == 0 and y.ncalls == 0: return 0
    if x.ncalls == 0: return 1
    if y.ncalls == 0: return -1
    xt = x.owntime/x.ncalls
    yt = y.owntime/y.ncalls
    if xt < yt: return 1
    if xt > yt: return -1
    return 0

def cmp_name(x,y):
    if x.name < y.name: return -1
    if x.name > y.name: return 1
    return 0

def cmp_file(x,y):
    if x.file < y.file: return -1
    if x.file > y.file: return 1
    return 0

def cmp_line(x, y):
    if x.lineno < y.lineno: return -1
    if x.lineno > y.lineno: return 1
    return 0

sorters = {
    'calls':cmp_ncalls,
    'total':cmp_tot, 'cumulative':cmp_tot,
    'file':cmp_file, 'module':cmp_file,
    'line':cmp_line,
    'name': cmp_name,
    'self': cmp_own, 'time': cmp_own,
    'percall': cmp_percall,
    'selfpercall':cmp_selfpercall
    }

def getSorter(criteria):
    ncriteria = len(criteria)
    if ncriteria==1:
        return SimpleSorter(criteria[0])
    else:
        return MultiSorter(criteria)

class SimpleSorter:
    def __init__(self, criterion):
        self.criterion = sorters[criterion]
    def __call__(self, x, y):
        return self.criterion(x,y)

class MultiSorter:
    def __init__(self, criteria):
        self.criteria = [sorters[criterion] for criterion in criteria]
    def __call__(self, x, y):
        for criterion in self.criteria:
            result = criterion(x, y)
            if result != 0:
                return result
        return 0
            
#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#

# Functions for restricting results

def restrict_re(funcs, rgxp):
    regexp = re.compile(rgxp)
    subset = []
    for func in funcs:
        if regexp.search(func.fullname()):
            subset.append(func)
    return subset

def restrict_pct(funcs, pct):
    nkeep = int(len(funcs)*pct)
    return funcs[:nkeep]

def restrict_count(funcs, n):
    return funcs[:n]

restriction_ops = {
    type("string") : restrict_re,
    type(0.5) : restrict_pct,
    type(1): restrict_count
    }

#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#
#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#
#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#=*=#

if __name__ == '__main__':
    import sys, getopt

    try:
        optlist, arg = getopt.getopt(sys.argv[1:], 'f:s:Dr:p:n:')
    except getopt.error, message:
        print """
Usage: python displayprof.py -f <profile> [options]
   <profile> is the profile file written by profiler.py.
   Options are:
    -s <sort> specifies the sorting order for the output.
          <sort>       sorting criterion
           calls        total number of calls to each function
           total        total amount ofa time spent in each function
           cumulative   synonym for 'total'
           file         the file containing the function definition
           module       synonym for 'file'
           line         line number in file of first line of function definition
           name         name of function
           self         time spent in function, excluding subroutine calls
           time         synonym for 'self'
           percall      total time 
    -D indicates that directory names should *not* be stripped
    -r <regexp> specifies a regular expression.  Only functions whose name
        matches the regular expression will be listed.
    -p <x> specifies the fraction of results to print.
    -n <nlines> specifies the total number of results to print.

  The order of the options -r, -p, and -n matters.  They can be repeated.
"""       
        sys.exit(1)

    filename = None
    sortmethods = []
    stripdirs = 1
    restrictions = []
    
    for opt in optlist:
        if opt[0] == '-f':
            filename = opt[1]
        elif opt[0] == '-s':
            sortmethods.append(opt[1])
        elif opt[0] == '-D':
            stripdirs = 0
        elif opt[0] == '-r':
            restrictions.append(opt[1])
        elif opt[0] == '-p':
            restrictions.append(string.atof(opt[1]))
        elif opt[0] == '-n':
            restrictions.append(string.atoi(opt[1]))

    if not filename:
        print "You must provide a file name with -f!"
        sys.exit(1)

    global prof
    prof = Stats(filename)
    if stripdirs:
        prof.strip_dirs()
    if sortmethods:
        apply(prof.sort_stats, sortmethods)
    prof.print_totals()
    apply(prof.print_stats, restrictions)
    print ''

    # Define a bunch of functions to be used interactively, saving the
    # user from having to know the name of the Stats instance.

    def totals():
        global prof
        print ''
        prof.print_totals()
        print ''
    
    def print_stats(*args):
        global prof
        print ''
        apply(prof.print_stats, args)
        print ''

    def print_callers(*args):
        global prof
        apply(prof.print_callers, args)
        print ''

    def print_callees(*args):
        global prof
        apply(prof.print_callees, args)
        print ''

    def sort_stats(*args):
        global prof
        return apply(prof.sort_stats, args)

    def reverse():
        global prof
        return prof.reverse()

    def strip_dirs():
        global prof
        return prof.strip_dirs()
        
    def butterfly(*args):
        global prof
        apply(prof.butterfly, args)
        print ''
