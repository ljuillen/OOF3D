
  Plasticity has special requirements for the time-stepping.

  For each time-step, the first thing to do is build the stiffness
matrix without the elasto-plastic tangent piece, just assuming
(large-strain) elasticity.  Then, the loop you go into starts with
solving this system, evaluating the stress, and building a new
master stiffness matrix *with* the elasto-plastic part.

  A possible challenge for OOF is that, at the start of the 
solution process, you do not have a stiffness matrix, and there's
no current scheme to convey to the properties that this is 
the first pass for this time-step.  

  So, we either need a special time-stepper that can pre-build
the stiffness matrix, or speical parameters for an existing 
stepper that tells it to do what we want.

  For plasticity, we will be taking uniform steps, which in terms
of the OOF solution sequence, means we are living in the world
of "Uniform" step-drivers.  

  In the "all-up" test-case, we've selected:

  -> Uniform stepping, with delta-t of 0.001 (bad choice for quasi-static?)
  -> Forward Euler stepping (bad choice?)
  -> Newton nonlinear solver.
  -> CG + ILU symmetric solver, BiCG + ILU unsymmetric solver

  IMPORTANT:

  Confusion about how exactly the prototype algorithm works:

  Does it or does it not accumulate Fp during the NR steps?

  If it does, then the initial K matrix built with the moved
boundary conditions can create permanent spurious yielding near
the moving boundary.  The solution to this is to use (build or find)
an initial elastic K matrix, equilibrate with that at the start 
of the global NR time-step, and then begin the plastic iterations
from the elastic-equilbirated starting state.

  If it does not, then it's safe to do the "naive" approach,
just build the K you want with the squashed elements, which 
might have condition or convergence problems, and NR-iterate
towards a solution, which will have some amount of Fp, which
will be the same, but maybe slower, than if you didn't do this.

  Looking at the code, it suggests that we're doing the second
thing -- the relevant datum is the fp_tau entry in the plastic
data container for the gausspoints, which gets updated (*not*
accumulated!) inside the "begin_element" routine of the 
plasticity property.

  Q: Is there a phase error?  The most recent fp_tau persists in 
the gauss-point object, but it's from the last matrix construction,
not the last solution.  How bad is this?  Feels small.

  --------

  Additional (minor) points of confusion:  (Sept. 24)

  The uniform time-stepper with forward Euler builds the matrices
at the start of every time-step, so there's no matrix
construction step for the last time.  This caused brief confusion,
because forward Euler is wrong for this problem. 

  I think we want a new stepper, provisionally called "Incremental", 
which can take time-steps without generating output, and which
could possibly have better initial guesses, because it can 
actually do the thing where you use the prior K matrix for
the next time-step's initial solution.

  Need to get a better grip on the steppers before this
can happen.

  Meanwhile:

  Also, in the example solution, there are no free DOFs?  It's a 
1x1x1 mesh, so all the nodes are boundary nodes, but only x component
is constrained by boundary conditions.  What happened to y and z?
(Possibly the thing is just mis-reporting?)

  (Request from SK:  Input/output pairs from the plasticity property,
    i.e. incoming F, generated w)

  (Did this, for low delta-F, we are getting good answers.)

  Stepper base classes are in engine/timestepper.py, except for the 
static one, which is in staticstep.py.  F and B Euler are in 
euler.py. 


  Object structure at Solve Time:
  ------------------------------

  When the solve button is pressed, several things are true.

  The problem is well-posed, in the sense that fields and equations
are defined.  Boundary conditions are defined, as a (possibly trivial)
function of time.

  There is an "Output schedule", a set of times at which outputs
are requested.  This is not necessarily related to the step size.

  There is a Solver, which contains a Time-Stepper, which in turn 
containts a Stepper, which may define a step size.  The solver
has a nonlinear solving algorithm (e.g. Newton or Picard), and matrix
solvers for symmetric or unsymmetric matrices.

  The "nonlinear solver" (which might be linear) attribute of the
subproblem is the thing that takes the linear system and computes
the DOFs at the next available time, using the stepper.
(See below.)


  Control flow:
  -------------

  Hitting the solve button takes you to the "Evolve" routine,
in SRC/engine/evolve.py.

  Evolve does a bunch of work at the initial time, including initializing
the static fields, which involves building the linear system at 
the initial time inside the "initializeStaticFields" routine in evolve.py.
According to the comments there, it is dispatched through the 
nonlinear solver, so nonlinearities are taken care of here.

  Then, Evolve loops over the times in the output schedule at which
the user has requested info, and for each time, calls "evolve_to" to 
bring the (possibly multiple) sub-problems up to that time.
  Note (again) that these times are unrelated to the stepper 
time-step.  The enclosed steppers will take as many steps as they
need to to hit the target time, with whatever algorithm they embody.
 
  The actual evolution happens in the "stepresult = " call,
to subproblem.nonlinear_solver.step(...)

  Evolve_to asks the steppers for their time-step, figures out the
new time at which it's evaluating the system, builds the linear 
system, and hands it off unconditionally to the nonlinear solver.
(In the trivial case, the nonlinear solver can be linear.)

  (The new time is passed through to the make_linear_system call --
this is where it should go to the properties, probably.)
