# -*- python -*-

# This software was produced by NIST, an agency of the U.S. government,
# and by statute is not subject to copyright in the United States.
# Recipients of this software assume all responsibilities associated
# with its operation, modification and maintenance. However, to
# facilitate maintenance we ask that before distributing modified
# versions of this software, you first contact the authors at
# oof_manager@nist.gov. 


# Tests of the nonlinear solvers on linear problems.

import unittest, os
import memorycheck
import math
from UTILS import file_utils
file_utils.generate = False

class OOF_LinearDiffusion(unittest.TestCase):
    # Solve a linear diffusion problem with a nonlinear solver.  The
    # reference output files were generated by a linear solver.

    def setUp(self):
        OOF.Microstructure.New(
            name='microstructure',
            width=1.0, height=1.0, depth=1.0,
            width_in_pixels=10, height_in_pixels=10, depth_in_pixels=10)
        OOF.Material.New(
            name='material', material_type='bulk')
        OOF.Material.Add_property(
            name='material', property='Thermal:Conductivity:Isotropic')
        OOF.Material.Add_property(
            name='material',
            property='Thermal:HeatCapacity:ConstantHeatCapacity')
        OOF.Material.Assign(
            material='material', microstructure='microstructure', pixels=every)
        OOF.Skeleton.New(
            name='skeleton', microstructure='microstructure', 
            x_elements=5, y_elements=5, z_elements=5,
            skeleton_geometry=TetraSkeleton(arrangement='moderate'))
        OOF.Mesh.New(
            name='mesh',
            skeleton='microstructure:skeleton',
            element_types=['TET4_4', 'D2_2', 'T3_3', 'Q4_4'])
        OOF.Subproblem.Field.Define(
            subproblem='microstructure:skeleton:mesh:default',
            field=Temperature)
        OOF.Subproblem.Field.Activate(
            subproblem='microstructure:skeleton:mesh:default',
            field=Temperature)
        OOF.Subproblem.Equation.Activate(
            subproblem='microstructure:skeleton:mesh:default', 
            equation=Heat_Eqn)
        OOF.Mesh.Boundary_Conditions.New(
            name='bc',
            mesh='microstructure:skeleton:mesh',
            condition=DirichletBC(
                field=Temperature,field_component='',
                equation=Heat_Eqn,eqn_component='',
                profile=ConstantProfile(value=0.0),
                boundary='XminYmin'))
        OOF.Mesh.Boundary_Conditions.New(
            name='bc<2>',
            mesh='microstructure:skeleton:mesh',
            condition=DirichletBC(
                field=Temperature,field_component='',
                equation=Heat_Eqn,eqn_component='',
                profile=ConstantProfile(value=1),
                boundary='XmaxYmax'))

        OOF.Mesh.Set_Field_Initializer(
            mesh='microstructure:skeleton:mesh', 
            field=Temperature, 
            initializer=FuncScalarFieldInit(
                function='0.0 if x < 0.9 or y < 0.9 else 1.0'))
        OOF.Mesh.Apply_Field_Initializers_at_Time(
            mesh='microstructure:skeleton:mesh',
            time=0.0)

        OOF.Mesh.Scheduled_Output.New(
            mesh='microstructure:skeleton:mesh',
            name=AutomaticName('Temperature//Direct Output'),
            output=ScheduledAnalysis(
                data=getOutput('Field:Value',field=Temperature),
                operation=DirectOutput(),
                domain=EntireMesh(),
                sampling=GridSampleSet(
                    x_points=9,y_points=9,z_points=9,
                    show_x=True,show_y=True,show_z=True)),
            scheduletype=AbsoluteOutputSchedule(),
            schedule=Periodic(delay=0.0,interval=0.1),
            destination=OutputStream(filename='nlbulktemp.dat',mode='w'))
        OOF.Mesh.Scheduled_Output.New(
            mesh='microstructure:skeleton:mesh',
            name=AutomaticName('Temperature//Average'), 
            output=ScheduledAnalysis(
                data=getOutput('Field:Value',field=Temperature),
                operation=AverageOutput(),
                domain=FaceBoundaryDomain(boundary='Ymax',side='BACK'),
                sampling=ContinuumSampleSet(order=automatic)),
            scheduletype=AbsoluteOutputSchedule(),
            schedule=Periodic(delay=0.0,interval=0.1),
            destination=OutputStream(filename='nlavgtoptemp.dat',mode='w'))


    @memorycheck.check("microstructure")
    def CNlinear(self):
        # This test uses a linear solver to generate the reference
        # data for the subsequent nonlinear solvers.
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    tolerance=1.e-6,
                    initialstep=0.01,
                    minstep=1e-8,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(
                        singlestep=CrankNicolson())),
                nonlinear_solver=NoNonlinearSolver(),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000),
                asymmetric_solver=BiConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))

        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=1.0)

        self.assert_(file_utils.fp_file_compare(
                'nlbulktemp.dat',
                os.path.join('mesh_data', 'nlbulktemp.dat'),
                tolerance=1.e-5))
        file_utils.remove('nlbulktemp.dat')
        self.assert_(file_utils.fp_file_compare(
                'nlavgtoptemp.dat',
                os.path.join('mesh_data', 'nlavgtoptemp.dat'),
                tolerance=1.e-6))
        file_utils.remove('nlavgtoptemp.dat')

    @memorycheck.check("microstructure")
    def CN(self):
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    initialstep=0.01,
                    tolerance=1.e-5,
                    minstep=1.e-8,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(singlestep=CrankNicolson())),
                nonlinear_solver=Newton(
                    relative_tolerance=1e-08,
                    absolute_tolerance=1.e-13,
                    maximum_iterations=200),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=1.0)

        self.assert_(file_utils.fp_file_compare(
                'nlbulktemp.dat',
                os.path.join('mesh_data', 'nlbulktemp.dat'),
                tolerance=1.e-5))
        file_utils.remove('nlbulktemp.dat')
        self.assert_(file_utils.fp_file_compare(
                'nlavgtoptemp.dat',
                os.path.join('mesh_data', 'nlavgtoptemp.dat'),
                tolerance=1.e-5))
        file_utils.remove('nlavgtoptemp.dat')

    @memorycheck.check("microstructure")
    def SS22(self):
        # Setting the AdaptiveDriver tolerance to 1.e-7 allows this
        # test to pass with the fp_file_compare tolerance set to
        # 1.e-6, but then the test runs really slowly.  Using
        # tolerances of 1.e-5 and 1.e-4, respectively, lets the test
        # run in a reasonable amount of time.
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    initialstep=0.01,
                    tolerance=1.e-5,
                    minstep=1.e-8,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(singlestep=SS22(theta1=0.5,theta2=0.5))),
                nonlinear_solver=Newton(
                    relative_tolerance=1e-08,
                    absolute_tolerance=1.e-13,
                    maximum_iterations=200),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=1.0)

        self.assert_(file_utils.fp_file_compare(
                'nlbulktemp.dat',
                os.path.join('mesh_data', 'nlbulktemp.dat'),
                tolerance=1.e-5))
        file_utils.remove('nlbulktemp.dat')
        self.assert_(file_utils.fp_file_compare(
                'nlavgtoptemp.dat',
                os.path.join('mesh_data', 'nlavgtoptemp.dat'),
                tolerance=1.e-5))
        file_utils.remove('nlavgtoptemp.dat')

    @memorycheck.check("microstructure")
    def RK4(self):
        # I can't get this to work with any parameter values.
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    initialstep=0.0001,
                    tolerance=1.e-3,
                    minstep=1.e-05,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(singlestep=RK4())),
                nonlinear_solver=Newton(
                    relative_tolerance=1e-08,
                    absolute_tolerance=1.e-13,
                    maximum_iterations=200),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=1.0)

        self.assert_(file_utils.fp_file_compare(
                'nlbulktemp.dat',
                os.path.join('mesh_data', 'nlbulktemp.dat'),
                tolerance=1.e-5))
        file_utils.remove('nlbulktemp.dat')
        self.assert_(file_utils.fp_file_compare(
                'nlavgtoptemp.dat',
                os.path.join('mesh_data', 'nlavgtoptemp.dat'),
                tolerance=1.e-6))
        file_utils.remove('nlavgtoptemp.dat')

    # The BackwardEuler and ForwardEuler tests are done at low
    # resolution and short times, because they're slow.

    @memorycheck.check("microstructure")
    def FE(self):
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    initialstep=0.1,
                    tolerance=1.e-6,
                    minstep=1.e-06,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(singlestep=ForwardEuler())),
                nonlinear_solver=Newton(
                    relative_tolerance=1e-08,
                    absolute_tolerance=1.e-13,
                    maximum_iterations=200),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=1.0)

        self.assert_(file_utils.fp_file_compare(
                'nlavgtoptemp.dat',
                os.path.join('mesh_data', 'nlavgtoptemp.dat'),
                tolerance=1.e-4,
                nlines=16))
        file_utils.remove('nlavgtoptemp.dat')
        self.assert_(file_utils.fp_file_compare(
                'nlbulktemp.dat',
                os.path.join('mesh_data', 'nlbulktemp.dat'),
                tolerance=1.e-3,
                nlines=910))
        file_utils.remove('nlbulktemp.dat')

    @memorycheck.check("microstructure")
    def BEpicard(self):
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    initialstep=0.001,
                    tolerance=1.e-3,
                    minstep=1.e-05,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(singlestep=BackwardEuler())),
                nonlinear_solver=Picard(
                    relative_tolerance=1e-08,
                    absolute_tolerance=1.e-13,
                    maximum_iterations=200),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=1.0)

        self.assert_(file_utils.fp_file_compare(
                'nlbulktemp.dat',
                os.path.join('mesh_data', 'nlbulktemp.dat'),
                tolerance=1.e-2))
        file_utils.remove('nlbulktemp.dat')
        self.assert_(file_utils.fp_file_compare(
                'nlavgtoptemp.dat',
                os.path.join('mesh_data', 'nlavgtoptemp.dat'),
                tolerance=1.e-2))
        file_utils.remove('nlavgtoptemp.dat')

    @memorycheck.check("microstructure")
    def BEnewton(self):
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    initialstep=0.001,
                    tolerance=1.e-3,
                    minstep=1.e-05,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(singlestep=BackwardEuler())),
                nonlinear_solver=Newton(
                    relative_tolerance=1e-08,
                    absolute_tolerance=1.e-13,
                    maximum_iterations=200),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=1.0)

        self.assert_(file_utils.fp_file_compare(
                'nlavgtoptemp.dat',
                os.path.join('mesh_data', 'nlavgtoptemp.dat'),
                tolerance=1.e-2))
        file_utils.remove('nlavgtoptemp.dat')
        self.assert_(file_utils.fp_file_compare(
                'nlbulktemp.dat',
                os.path.join('mesh_data', 'nlbulktemp.dat'),
                tolerance=1.e-2))
        file_utils.remove('nlbulktemp.dat')

    def tearDown(self):
        # outputdestination is imported explicitly so that it's still
        # found even if earlier tests are commented out.
        from ooflib.engine.IO import outputdestination
        outputdestination.forgetTextOutputStreams()
        OOF.Material.Delete(name='material')


# Elasticity with a floating boundary condition.  A thermal diffusion
# version of this problem is done in nonlinear_floatbc.py.  Perhaps
# this test should be moved to that file.

class OOF_NLElastic(unittest.TestCase):
    def setUp(self):
        self.endtime = 0.1
        OOF.Microstructure.New(
            name='microstructure',
            width=1.0, height=1.0, depth=1.0,
            width_in_pixels=10, height_in_pixels=10, depth_in_pixels=10)
        OOF.Material.New(
            name='material', material_type='bulk')
        OOF.Material.Assign(
            material='material', microstructure='microstructure', pixels=all)
        # Reset the default parameter values for isotropic elasticity.
        # This shouldn't be necessary if earlier tests clean up after
        # themselves properly.
        OOF.Property.Parametrize.Mechanical.Elasticity.Isotropic(
            cijkl=IsotropicRank4TensorCij(c11=1.0,c12=0.5))
        OOF.Material.Add_property(
            name='material', property='Mechanical:Elasticity:Isotropic')
        OOF.Material.Add_property(
            name='material',
            property='Mechanical:MassDensity:ConstantMassDensity')
        OOF.Skeleton.New(
            name='skeleton',
            microstructure='microstructure',
            x_elements=5, y_elements=5, z_elements=5,
            skeleton_geometry=TetraSkeleton(arrangement='moderate'))
        OOF.Mesh.New(
            name='mesh',
            skeleton='microstructure:skeleton',
            element_types=['TET4_4', 'D2_2', 'T3_3', 'Q4_4'])
        OOF.Subproblem.Field.Define(
            subproblem='microstructure:skeleton:mesh:default',
            field=Displacement)
        OOF.Subproblem.Field.Activate(
            subproblem='microstructure:skeleton:mesh:default',
            field=Displacement)
        OOF.Subproblem.Equation.Activate(
            subproblem='microstructure:skeleton:mesh:default',
            equation=Force_Balance)
        OOF.Mesh.Boundary_Conditions.New(
            name='bc',
            mesh='microstructure:skeleton:mesh',
            condition=DirichletBC(
                field=Displacement, field_component='x',
                equation=Force_Balance, eqn_component='x',
                profile=ConstantProfile(value=0.0),
                boundary='Xmin'))
        OOF.Mesh.Boundary_Conditions.New(
            name='bc<2>',
            mesh='microstructure:skeleton:mesh', 
            condition=DirichletBC(
                field=Displacement,field_component='y',
                equation=Force_Balance,eqn_component='y',
                profile=ConstantProfile(value=0.0),
                boundary='XminYminZmin'))
        OOF.Mesh.Boundary_Conditions.New(
            name='bc<2>z',
            mesh='microstructure:skeleton:mesh', 
            condition=DirichletBC(
                field=Displacement,field_component='z',
                equation=Force_Balance,eqn_component='z',
                profile=ConstantProfile(value=0.0),
                boundary='XminYminZmin'))
        OOF.Mesh.Boundary_Conditions.New(
            name='bc<3>', 
            mesh='microstructure:skeleton:mesh',
            condition=FloatBC(
                field=Displacement,field_component='x',
                equation=Force_Balance,eqn_component='x',
                profile=ConstantProfile(value=0.0),
                boundary='Xmax'))
        OOF.Mesh.Boundary_Conditions.New(
            name='bc<4>', 
            mesh='microstructure:skeleton:mesh',
            condition=FloatBC(
                field=Displacement,field_component='y',
                equation=Force_Balance,eqn_component='y',
                profile=ConstantProfile(value=0.0),
                boundary='Xmax'))
        OOF.Mesh.Boundary_Conditions.New(
            name='bc<5>', 
            mesh='microstructure:skeleton:mesh',
            condition=FloatBC(
                field=Displacement,field_component='z',
                equation=Force_Balance,eqn_component='z',
                profile=ConstantProfile(value=0.0),
                boundary='Xmax'))

        OOF.Mesh.Scheduled_Output.New(
            mesh='microstructure:skeleton:mesh',
            name='riiight',
            output=ScheduledAnalysis(
                data=getOutput('Field:Value', field=Displacement),
                operation=AverageOutput(),
                domain=FaceBoundaryDomain(boundary='Xmax', side='BACK'),
                sampling=ContinuumSampleSet(order=automatic)),
            scheduletype=AbsoluteOutputSchedule(),
            schedule=Periodic(delay=0.0,interval=self.endtime/10),
            destination=OutputStream(filename='riiight.out', mode='w'))

        OOF.Mesh.Scheduled_Output.New(
            mesh='microstructure:skeleton:mesh',
            name='avgstress',
            output=ScheduledAnalysis(
                data=getOutput('Flux:Value', flux=Stress),
                operation=AverageOutput(),
                domain=EntireMesh(),
                sampling=ContinuumSampleSet(order=automatic)),
            scheduletype=AbsoluteOutputSchedule(),
            schedule=Periodic(delay=0.0,interval=self.endtime/10),
            destination=OutputStream(filename='stress_nl2.out', mode='w'))

        OOF.Mesh.Set_Field_Initializer(
            mesh='microstructure:skeleton:mesh',
            field=Displacement,
            initializer=FuncThreeVectorFieldInit(fx='0.1*x',fy='0.0',fz='0.0'))
        OOF.Mesh.Set_Field_Initializer(
            mesh='microstructure:skeleton:mesh',
            field=Displacement_t, 
            initializer=ConstThreeVectorFieldInit(cx=0.0,cy=0.0,cz=0.0))
        OOF.Mesh.Apply_Field_Initializers_at_Time(
            mesh='microstructure:skeleton:mesh',
            time=0.0)
    def check(self):
        self.assert_(file_utils.fp_file_compare(
                'riiight.out',
                os.path.join('mesh_data', 'riiight.out'),
                tolerance=1.e-4))
        file_utils.remove('riiight.out')
        self.assert_(file_utils.fp_file_compare(
                'stress_nl2.out',
                os.path.join('mesh_data', 'stress_nl2.out'),
                tolerance=1.e-4))
        file_utils.remove('stress_nl2.out')

    @memorycheck.check("microstructure")
    def LinearCN(self):
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    tolerance=1e-4,
                    initialstep=0.001,
                    minstep=1e-08,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(
                        singlestep=CrankNicolson())),
                nonlinear_solver=NoNonlinearSolver(),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000),
                asymmetric_solver=BiConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=self.endtime)
        self.check()
    @memorycheck.check("microstructure")
    def LinearSS22(self):
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    tolerance=1e-4,
                    initialstep=0.001,
                    minstep=1e-08,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(
                        singlestep=SS22(theta1=0.5,theta2=0.5))),
                nonlinear_solver=NoNonlinearSolver(),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000),
                asymmetric_solver=BiConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=self.endtime)
        self.check()
    @memorycheck.check("microstructure")
    def NonlinearSS22(self):
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    tolerance=1e-4,
                    initialstep=0.001,
                    minstep=1e-08,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(
                        singlestep=SS22(theta1=0.5,theta2=0.5))),
                nonlinear_solver=Newton(
                    relative_tolerance=1e-08,
                    absolute_tolerance=1e-13,
                    maximum_iterations=200),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000),
                asymmetric_solver=BiConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=self.endtime)
        self.check()
    @memorycheck.check("microstructure")
    def NonlinearCN(self):
        OOF.Subproblem.Set_Solver(
            subproblem='microstructure:skeleton:mesh:default',
            solver_mode=AdvancedSolverMode(
                time_stepper=AdaptiveDriver(
                    tolerance=1e-4,
                    initialstep=0.001,
                    minstep=1e-08,
                    errorscaling=AbsoluteErrorScaling(),
                    stepper=TwoStep(
                        singlestep=CrankNicolson())),
                nonlinear_solver=Newton(
                    relative_tolerance=1e-08,
                    absolute_tolerance=1e-13,
                    maximum_iterations=200),
                symmetric_solver=ConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000),
                asymmetric_solver=BiConjugateGradient(
                    preconditioner=ILUPreconditioner(),
                    tolerance=1e-13,
                    max_iterations=1000)))
        OOF.Mesh.Solve(
            mesh='microstructure:skeleton:mesh',
            endtime=self.endtime)
        self.check()

    def tearDown(self):
        from ooflib.engine.IO import outputdestination
        outputdestination.forgetTextOutputStreams()
        OOF.Material.Delete(name='material')


#=--=##=--=##=--=##=--=##=--=##=--=##=--=##=--=##=--=##=--=##=--=#

diffusion_set = [
    ## CNLinear just generates the reference files for the rest of
    ## the LinearDiffusion tests.  It should come first.
    OOF_LinearDiffusion("CNlinear"),
    OOF_LinearDiffusion("CN"),
    OOF_LinearDiffusion("SS22"),
    OOF_LinearDiffusion("BEpicard"),
    OOF_LinearDiffusion("BEnewton"),
    # OOF_LinearDiffusion("RK4"),  ## TODO: Why doesn't this work?
    # OOF_LinearDiffusion("FE"),
]

elastic_set = [
    OOF_NLElastic("LinearCN"),
    OOF_NLElastic("LinearSS22"),
    OOF_NLElastic("NonlinearCN"),
    OOF_NLElastic("NonlinearSS22")
]

test_set = diffusion_set + elastic_set

#test_set = elastic_set
    
    
